/*
 * elliptic curve utilities
 *
 * (c) 2013 Prof Dr Andreas Mueller, Hochschule Rapperswil
 */
#include <ec.h>
#include <limits>
#include <math.h>
#include <stdexcept>

/* these constants are only used to produce something reasonable
 * when exporting everything to a metapost source file 
 */
double	scale = 1.;
double	xoffset = 0;
double	yoffset = 0;

Point::Point() {
	x = 0;
	y = 1;
	z = 0;
}

double	Point::rescale(double v) const {
	return round(1000 * scale * v) / 1000.;
}

void	Point::normalize() {
	double	n = sqrt(x * x + y * y + z * z);
	x /= n;
	y /= n;
	z /= n;
}

/**
 * \brief Template to let the compiler expand powers to products
 *
 * This template uses template metaprogramming to expand integer
 * powers. Computing a known power n is done by applying the
 * function power<n> to the argument. The compiler will then expand
 * power<n>(x) to the product of n copies of x.
 */
template<int n>
double	power(double x) { return x * power<n-1>(x); }
template<>
double	power<2>(double x) { return x * x; }

/**
 * \brief Power macro
 *
 * This macro is used to replace the Power(x,n) generated by Mathematica
 * in the formulas below. It forwards a call to Power(x,n) to the template
 * power<n>(x), which works because the exponent is always fixed.
 */
#define	Power(x,n)	power<n>(x)

double	EllipticCurve::verify(const Point& u) const {
	return power<3>(u.x) + a * u.x * power<2>(u.z) + b * power<3>(u.z)
		- power<2>(u.y) * u.z;
}

Point	EllipticCurve::invert(const Point& a) const {
	Point	result = a;
	result.y = -result.y;
	return result;
}

/**
 * \brief Intersection of a line through two points with the curve
 *
 * This is the basic building block for the group operation in the elliptic
 * curve. The method is essentially built from output of Mathematica 
 * pasted in here. A bunch of macro definitions then ensure that the
 * Mathematica-generated code performs as expected when compiled.
 * To get the product of u and v, apply the invert method to the result
 * \param u
 * \param v
 */
Point	EllipticCurve::product(const Point& u, const Point& v) const {
	if (u.x == v.x) { return Point(); }
#define	x0	u.x
#define	y0	u.y
#define	z0	u.z
#define	x1	v.x
#define	y1	v.y
#define	z1	v.z
	double	t =
(2*Power(x0,3) - 3*Power(x0,2)*x1 - 2*Power(y0,2)*z0 + 2*y0*y1*z0 + 
      2*a*x0*Power(z0,2) - a*x1*Power(z0,2) + 2*b*Power(z0,3) + 
      Power(y0,2)*z1 - 2*a*x0*z0*z1 - 3*b*Power(z0,2)*z1)/
    (Power(x0,3) - 3*Power(x0,2)*x1 + 3*x0*Power(x1,2) - Power(y0,2)*z0 + 
      2*y0*y1*z0 - Power(y1,2)*z0 + a*x0*Power(z0,2) - a*x1*Power(z0,2) + 
      b*Power(z0,3) + Power(y0,2)*z1 - 2*y0*y1*z1 - 2*a*x0*z0*z1 + 
      2*a*x1*z0*z1 - 3*b*Power(z0,2)*z1 + a*x0*Power(z1,2) + 
      3*b*z0*Power(z1,2));

	Point	result((1-t) * u.x + t * v.x, (1-t) * u.y + t * v.y,
			(1-t) * u.z + t * v.z);
	result.normalize();
	return result;
}

/**
 * \brief Third intersection point for a tangent
 *
 * This is the basic building block for the squaring operation
 * on the elliptic curve. To actually get the square of the argument
 * point, apply the invert function.
 */
Point	EllipticCurve::sqr(const Point& u) const {
#define	x0	u.x
#define	y0	u.y
#define	z0	u.z

	double	t = 

   (-3*Power(a,3)*x0*Power(y0,2)*Power(z0,4) - 
      Power(a,2)*Power(z0,2)*(-6*Power(x0,3)*Power(y0,2) + 4*Power(x0,4)*z0 - 
         2*Power(y0,4)*z0 + (2 + 3*b)*Power(y0,2)*Power(z0,3) + Power(z0,5) + 
         Power(x0,2)*(8*Power(y0,2)*z0 - 4*Power(z0,3))) + 
      3*a*x0*(3*Power(x0,4)*Power(y0,2) + 4*Power(x0,3)*Power(z0,3) - 
         4*b*Power(x0,2)*Power(z0,4) + 
         2*Power(z0,2)*(Power(y0,2) - Power(z0,2))*
          (Power(y0,2) - b*Power(z0,2)) - 
         2*x0*z0*(Power(y0,4) - 2*(2 + 3*b)*Power(y0,2)*Power(z0,2) + 
            Power(z0,4))) + 3*x0*
       (2*Power(x0,2)*(Power(y0,2) + Power(z0,2))*
          (Power(y0,2) + 3*b*Power(z0,2)) + 
         Power(y0,2)*Power(Power(y0,2) - (2 + 3*b)*Power(z0,2),2) + 
         Power(x0,3)*(3*(2 + 3*b)*Power(y0,2)*z0 - 3*Power(z0,3)) + 
         x0*z0*(Power(y0,4) + 2*b*Power(y0,2)*Power(z0,2) - 
            3*Power(b,2)*Power(z0,4))))/
    (y0*(Power(y0,8) - 3*Power(3 - 2*a,2)*Power(x0,6)*Power(z0,2) - 
        6*Power(y0,6)*Power(z0,2) + 12*Power(y0,4)*Power(z0,4) + 
        Power(a,3)*Power(y0,4)*Power(z0,4) - 8*Power(y0,2)*Power(z0,6) - 
        2*Power(a,3)*Power(y0,2)*Power(z0,6) - 
        27*Power(b,3)*Power(y0,2)*Power(z0,6) - Power(a,3)*Power(z0,8) - 
        2*Power(x0,5)*z0*((9 - 6*a + 9*Power(a,2))*Power(y0,2) + 
           Power(3 - 2*a,2)*Power(z0,2)) - 
        9*Power(b,2)*Power(z0,4)*
         (3*Power(x0,4) - 3*Power(y0,4) + 2*Power(x0,3)*z0 + 
           6*a*x0*Power(y0,2)*z0 + a*Power(x0,2)*Power(z0,2) + 
           6*Power(y0,2)*Power(z0,2)) + 
        2*Power(x0,3)*z0*((-1 + 6*a)*Power(y0,4) - 
           2*a*(9 + a + 5*Power(a,2))*Power(y0,2)*Power(z0,2) + 
           2*a*(-3 + 2*a)*Power(z0,4)) + 
        a*Power(x0,2)*Power(z0,2)*
         (3*(1 + 6*a)*Power(y0,4) - 
           4*(3 + 9*a + 2*Power(a,2))*Power(y0,2)*Power(z0,2) + 
           a*(-9 + 4*a)*Power(z0,4)) + 
        Power(x0,4)*((-3 + 9*a)*Power(y0,4) - 
           2*(6 + 5*a + 12*Power(a,2))*Power(y0,2)*Power(z0,2) + 
           a*(-27 + 24*a - 4*Power(a,2))*Power(z0,4)) - 
        2*a*x0*z0*(3*Power(y0,6) - 2*(6 + a)*Power(y0,4)*Power(z0,2) + 
           (12 + 5*a + Power(a,3))*Power(y0,2)*Power(z0,4) + a*Power(z0,6)) + 
        b*(27*Power(x0,6)*Power(y0,2) + 
           3*a*Power(x0,2)*Power(z0,4)*
            ((2 - 15*a)*Power(y0,2) + 4*Power(z0,2)) + 
           18*Power(x0,5)*(3*Power(y0,2)*z0 + (3 - 2*a)*Power(z0,3)) + 
           6*Power(x0,4)*(9*Power(y0,2)*Power(z0,2) + 
              2*(3 - 2*a)*Power(z0,4)) + 
           6*a*x0*Power(z0,3)*(6*Power(y0,4) - 
              (12 + a)*Power(y0,2)*Power(z0,2) + a*Power(z0,4)) - 
           Power(y0,2)*Power(z0,2)*
            (9*Power(y0,4) - 36*Power(y0,2)*Power(z0,2) + 
              2*(18 + Power(a,3))*Power(z0,4)) + 
           4*Power(x0,3)*(5*Power(y0,2)*Power(z0,3) - 
              3*(-3 + a)*a*Power(z0,5)))));

	Point	result(
		x0 + t*(-Power(y0,3) + 2*a*x0*y0*z0 + 2*y0*Power(z0,2) + 
			3*b*y0*Power(z0,2)),
		y0 + t*(x0*Power(y0,2) + 3*Power(x0,2)*z0 - 2*a*Power(x0,2)*z0
			- 3*b*x0*Power(z0,2) + a*Power(z0,3)),
		z0 + t*(-3*Power(x0,2)*y0 - 2*x0*y0*z0 - a*y0*Power(z0,2))
	);
	result.normalize();
	return result;
}

/**
 * \brief Compute powers of a given point
 *
 * This method uses the well known repeated squaring algorithm for fast
 * exponentiation.
 */
Point	EllipticCurve::pow(const Point& u, int n) const {
	Point	result;
	Point	m = u;
	while (n) {
		if (n & 0x1) {
			result = invert(product(result, m));
		}
		m = invert(sqr(m));
		n >>= 1;
	}
	return result;
}

/**
 * \brief Compute a point given the x value
 */
Point	EllipticCurve::point(double x) const {
	double y2 = x * x * x + a * x + b;
	if (y2 < 0) {
		throw std::runtime_error("no point on curve for this x");
	}
	return Point(x, sqrt(y2), 1);
}

std::ostream&	operator<<(std::ostream& out, const Point& p) {
	return out << "(" << p.rescale(p.x/p.z - xoffset)
		<< "," << p.rescale(p.y/p.z - yoffset) << ")";
}
